fud2 Parametric States
======================

This is in reference to the parametric states subheader in the now outdated [fud2-next.md](fud2-next.md). Let's consider two different implementations of parametric states. In the first, assume ops cannot have different behavior based on the parametric parameter of a state, though they can choose to only except states with certain parametric parameters (e.g. accept `state1[t1]` but not `state1[t2]`). This is in service of reducing code dup when a op can be applied to multiple states unmodified by collapsing those states into a single state with a parametric parameter. This reduces the number of states which need to be specified, but doesn't actually reduce code duplication. Functions already exist in fud2's scripting language, so a function which encapsulates the shared behavior of these ops can be created and called in multiple ops operating on different states. I personally don't think the ergonomic improvement is worth the extra complexity (both in implementation and in the scripting language) and in practice, I didn't see many case where an implementation like this would be helpful.

I think a useful implementation, would have to let ops modify their behavior based on a state's parametric parameter. The problem parametric states are trying to solve (that I actually saw in some ops) is some ops want to tag extra information to the states they return for other ops to read and adjust their behavior accordingly. For example, maybe an op generates source code with a special property and wants to signal to the op which compiles this source code to use a special flag to handle this property in it's compiler call.

This extra information is somewhat different to how parametric types normally work. Normally parametric types are used to reuse code written for one type when such code would be identical to write for another type, e.g. `List<T>` in Java. In that example no matter what type `T` is, the methods, functions taking in `this`, will always do the same thing. `List<Float>` is different from `List<Integer>` because the data stored in each list is different, not because the methods are different. For example, in `l.get(0).add(l.get(1))` if the value `l.get(0)` is a `Float`, it supplies a different implementation of `add()` than if `l.get(0)` were an `Integer`. The important bit of this is the different behavior is supplied by the value, not by the methods of `List`.

In contrast, states have no data and supply no functions. Instead ops, the things taking in states with different parametric parameters *want* to directly read parametric parameters and supply different behavior themselves. This comes through in the ideas in [fud2-next.md](fud2-next.md) as the parametric parameters are all just booleans. I think thinking of parametric parameters as tags might opposed to parametric polymophism might be easier. I'm not sure what the name of this language feature (or pattern or something that might have been studied) is.

Thinking about parametric parameters as tags for ops to read I think suggests a few things about the design:
- An MVP probably shouldn't involve the planners. This feature can be useful without any type checking and just getting the tags working might require a fair bit of effort across the stack.
- One case where type checking could be helpful is when an op which takes in `state1[t1]` and wants to return `state2[t1]`, keeping the tag invariant between the input and output. This would be hard though as it requires some sort of analysis of scripts themselves which currently isn't done.
- A user might want an op to return different states for different tags on an input. This would require additional planner support (and thinking of an efficient algorithm could be hard) but it might not require changing fud2's internal representation.
